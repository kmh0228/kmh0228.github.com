<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title></title>
</head>
<body style="background:#ccc;">
<div id="mf" style="margin:200px auto;"></div>
<input type="text" value="x"/>
<input type="text" value="2"/>
<input type="text" value="true"/>
<input type="button" value="旋转"/>
</body>
</html>

<script>
//公用方法
	function drag(obj,fndown,fnmove,fnup){
		if(!obj)return;
		if(arguments.length==2){
			var fnmove=fndown;
			fndown=null;
		}
		var mousedown=function(ev){
			var oEvent = ev||event;
			var oldX = oEvent.clientX;
			var oldY = oEvent.clientY;
			fndown&&fndown();
			var mousemove=function(ev){
				var oEvent = ev||event;
				var newX = oEvent.clientX;
				var newY = oEvent.clientY;
				fnmove&&fnmove(newX-oldX,newY-oldY);
			};
			document.addEventListener('mousemove',mousemove);
			
			var mouseup=function(){
				document.removeEventListener('mousemove',mousemove);
				document.removeEventListener('mousemove',mousemove);
				fnup&&fnup();
				obj.releaseCapture&&obj.releaseCapture();
			};
			document.addEventListener('mouseup',mouseup);
			obj.setCapture&&obj.setCapture();
			ev.preventDefault();
		};
		obj.addEventListener('mousedown',mousedown);
	}
	

//参数  id为魔方容器的id，opts为魔方的属性设置
//opts  > borderLength:num 魔方边长, vColor:color魔方材料颜色 , colors:[[][][][][][]]魔方各个面的颜色  order:num 魔方阶乘 , mouseSen 拖拽时鼠标灵敏度 , oneTime 转动一下时需要的时间 
function Cube(id,opts){
	//储存Cube信息
	this.container=document.getElementById(id);//容器
	this.opts=opts||{};//所有信息
	this.order=this.opts.order||3;//设定魔方阶乘，默认是三阶
	this.borderLength=this.opts.borderLength||240;//容器边长，默认240
	this.boxBorderLength=parseInt(this.borderLength/this.order/2)*2;//计算出每个块的边长
	this.borderLength=this.boxBorderLength*this.order;//重计算容器边长，避免小数点误差
	this.vColor=this.opts.vColor||'#fff';//设定魔方材料颜色，默认是白色
	this.mouseSen=this.opts.mouseSen||1;//默认鼠标灵敏度是1
	this.oneTime=this.opts.oneTime||500;//转动一次的时间 毫秒

	//置空容器
	this.container.innerHTML='';
	
	//建立DOM结构
	this.boxsData=[];//存放魔方的每个小块 格式[{dom:dom,x:0,y:0,z:0,coorX:'x',coorY:'y',coorZ:'z',faces:[dom,dom..]},,] 
	
	this.boxsDataLength=Math.pow(this.order,3);
	for(var i=0;i<this.boxsDataLength;i++){
		var boxs={};
		boxs.dom=document.createElement('div');//建立小块
		this.container.appendChild(boxs.dom);//将小块添加进去
		boxs.faces=[];//存放每个小块的6个面
		for(var j=0;j<6;j++){
			var aDiv=document.createElement('div');//建立面
			boxs.dom.appendChild(aDiv);//将面添加进去
			boxs.faces.push(aDiv);//存储面
		}
		boxs.x=boxs.intx=i%this.order;
		boxs.y=boxs.inty=(parseInt(i/this.order))%this.order;
		boxs.z=boxs.intz=(parseInt(i/Math.pow(this.order,2)))%this.order;
		boxs.coorX='x';
		boxs.coorY='y';
		boxs.coorZ='z';
		this.boxsData.push(boxs);//存储小块
//boxs.dom.innerHTML=i+' loc'+boxs.x+' '+boxs.y+' '+boxs.z;
	}
	
	//初始化容器大小和小块位置
	this.initStyle();
	//初始化各面颜色
	this.initColors=this.opts.colors||[['yellow'],['#fff'],['green'],['blue'],['red'],['orange']];
	//this.initColors=this.opts.colors||[['none'],['none'],['none'],['none'],['none'],['none']];
	this.initColor();
	
	//给容器加旋转事件
	this.containerMouseMove();
	
}

//设置初始样式
Cube.prototype.initStyle=function(){
	//设置容器样式  宽高 相对定位 开启3D效果
	this.container.style.width=this.container.style.height=this.borderLength+'px';
	this.container.style.positon='relative';
	this.container.style.WebkitTransformStyle='preserve-3d';
	this.container.style.WebkitTransform='perspective(800px) rotateZ(0deg) rotateY(0deg) rotateX(0deg)';
	//设置每个盒子的样式 宽高 固定定位到中间 边线  平移量
	for(var i=0;i<this.boxsDataLength;i++){
		this.boxsData[i].dom.style.position='absolute';
		this.boxsData[i].dom.style.width=this.boxsData[i].dom.style.height=this.boxsData[i].dom.style.left=this.boxsData[i].dom.style.top=this.boxBorderLength+'px';
		//设置没个盒子偏移量
		var x=this.boxsData[i].translateX=(this.boxsData[i].x+0.5-(this.order/2))*this.boxBorderLength;
		var y=this.boxsData[i].translateY=(this.boxsData[i].y+0.5-(this.order/2))*this.boxBorderLength;
		var z=this.boxsData[i].translateZ=(this.boxsData[i].z+0.5-(this.order/2))*this.boxBorderLength;
		var rx=this.boxsData[i].rotateX=0;
		var ry=this.boxsData[i].rotateY=0;
		var rz=this.boxsData[i].rotateZ=0;
		this.boxsData[i].dom.style.WebkitTransformStyle='preserve-3d';
		this.boxsData[i].dom.style.WebkitTransform='rotateX('+rx+'deg) rotateY('+ry+'deg) rotateZ('+rz+'deg) translateZ('+z+'px) translate('+x+'px,'+y+'px)';
		for(var j=0;j<6;j++){
			//设置每个面的属性
			this.boxsData[i].faces[j].style.position='absolute';
			this.boxsData[i].faces[j].style.top=this.boxsData[i].faces[j].style.left=0;
			this.boxsData[i].faces[j].style.width=this.boxsData[i].faces[j].style.height='100%';
			this.boxsData[i].faces[j].style.border='2px solid '+this.vColor;//设置边线 默认2px
			this.boxsData[i].faces[j].style.boxSizing='border-box';//设置边线 属性
			this.boxsData[i].faces[j].style.background=this.vColor; //设置面的原始颜色 同材料颜色
			this.boxsData[i].faces[j].style.borderRadius=parseInt(this.boxBorderLength/10)+'px'; //设置面的圆角，默认每小块的1/10
			//设置每个面的偏移量
			var tx=0,ty=0,tz=0,rx=0,ry=0,rz=0;

			switch(j){
				case 0:ty=-this.boxBorderLength/2;rx=90;break;
				case 1:ty=this.boxBorderLength/2;rx=90;break;
				case 2:tx=-this.boxBorderLength/2;ry=90;break;
				case 3:tx=this.boxBorderLength/2;ry=90;break;
				case 4:tz=this.boxBorderLength/2;break;
				case 5:tz=-this.boxBorderLength/2;break;
			}
			var transformstyle='';
			transformstyle+=tx?'translateX('+tx+'px) ':'';
			transformstyle+=ty?'translateY('+ty+'px) ':'';
			transformstyle+=tz?'translateZ('+tz+'px) ':'';
			transformstyle+=rx?'rotateX('+rx+'deg) ':'';
			transformstyle+=ry?'rotateY('+ry+'deg) ':'';
			transformstyle+=rz?'rotateZ('+rz+'deg) ':'';
			this.boxsData[i].faces[j].style.WebkitTransform=transformstyle;
		}
		
	}
};

//干掉魔方上所有颜色的方法，，只剩下材料颜色
Cube.prototype.delColor=function(){
	for(var i=0;i<this.boxsDataLength;i++){
		var doms=this.boxsData[i].faces;
		for(var j=0;j<6;j++){
			doms[j].style.backgroundColor=this.vColor;
		}
	}
}
//设定魔方颜色设定 格式[[color,color,上面的9个点],[下],[]..]
Cube.prototype.setColor=function(colorarr){
	this.delColor();
	this.colors=colorarr||this.initColors;
	//容错this.colors,如果每一个面只给一个颜色或少给颜色，按前一个颜色算;
	for(i=0;i<+6;i++){
		if(!this.colors[i]){this.colors[i]=this.colors[i-1];}
		for(var j=0;j<Math.pow(this.order,2);j++){
			if(!this.colors[i][j]){this.colors[i][j]=this.colors[i][j-1]}
		}
	}
	var b=this.order-1;
	var filter=[{y:0},{y:b},{x:0},{x:b},{z:b},{z:0}];
	//添加颜色
	for(var i=0;i<6;i++){
		var dom=this.getDomByPos(filter[i]);
		for(var j=0;j<dom.length;j++){
			dom[j].faces[i].style.background=this.colors[i][j];
		}
	}
};
//初始化颜色
Cube.prototype.initColor=function(){
	this.setColor();
}

//通过坐标筛选boxsData; json格式 {x:num,y:num,z:num}  可省略条件
Cube.prototype.getDomByPos=function(filterJson){
	var arr=[];
	var filterJson=filterJson||{};
	var x=/[\d+]/.test(filterJson.x)?filterJson.x:'all';
	var y=/[\d+]/.test(filterJson.y)?filterJson.y:'all';
	var z=/[\d+]/.test(filterJson.z)?filterJson.z:'all';
	for(var i=0;i<this.boxsDataLength;i++){
		if((this.boxsData[i].x==x||x=='all')&&(this.boxsData[i].y==y||y=='all')&&(this.boxsData[i].z==z||z=='all')){
			arr.push(this.boxsData[i]);
		}
	}
	return arr;
};

//给容器加拖拽时间
Cube.prototype.containerMouseMove=function(){
	var _this=this;
	//默认状态为X,Y旋转0deg
	this.oldRotateX=this.rotateX=this.rotateX||0;
	this.oldRotateY=this.rotateY=this.rotateX||0;
	this.oldRotateZ=this.rotateZ=this.rotateZ||0;
	
	var scale,scale2;
	
	drag(_this.container,function(){
		_this.oldRotateX=_this.rotateX;
		_this.oldRotateY=_this.rotateY;
		_this.oldRotateZ=_this.rotateZ;
		var dydeg=_this.rotateY%360;
		if(dydeg<0){dydeg+=360;}
		if(dydeg>180){dydeg=360-dydeg;}
		scale=(90-(dydeg))/90;
		var dydeg2=_this.rotateY%360;
		if(dydeg2<0){dydeg2+=360;}
		if(dydeg2>270){dydeg2=540-dydeg2;}else if(dydeg2<90){dydeg2=180-dydeg2;}
		scale2=(180-dydeg2)/90;
	},function(dx,dy){
		_this.rotateY=_this.oldRotateY+(dx*_this.mouseSen);
		_this.rotateX=_this.oldRotateX-(dy*_this.mouseSen*scale);
		if(_this.rotateX>45){_this.rotateX=45;}else if(_this.rotateX<-45){_this.rotateX=-45;}
		_this.rotateZ=_this.oldRotateZ-(dy*_this.mouseSen*scale2);
		if(_this.rotateZ>45){_this.rotateZ=45;}else if(_this.rotateZ<-45){_this.rotateZ=-45;}
		_this.container.style.WebkitTransform='perspective(800px) rotateY('+_this.rotateY+'deg) rotateX('+_this.rotateX+'deg) rotateZ('+_this.rotateZ+'deg)';
	});
};

//设置容器拖拽时候的鼠标灵敏度
Cube.prototype.setMouseSen=function(n){
	this.mouseSen=n;
};


//设置魔方操作  参数 轴XYZ 第几排 顺/逆时针 旋转完成后
Cube.prototype.turn=function(coor,num,dir,fnComplete){
	//阻止多次点击
	this.runing=this.runing||false;
	if(this.runing)return;
	var num=num||0;
	if(num>this.order-1)return;
	this.runing=true;
	if(dir==false){var dir=false}else{var dir=true};//true代表正向
	//找到操作的元素
	var filter={};
	filter[coor]=num;
	var dom=this.seletDoms=this.getDomByPos(filter);
	//添加动作
	var n=0;//记录转动完成的数
	var domLength=dom.length;
	var _this=this;
	function transend(){
		this.removeEventListener('transitionend',transend,false);
		this.style.transition='none';
		n++;
		if(n==domLength){
			//全部旋转完成后
			switch(coor){
				case 'x':
					if(dir){
						for(var i=0;i<domLength;i++){
							var y=dom[i].y;
							var z=dom[i].z;
							dom[i].y=_this.order-1-z;
							dom[i].z=y;
						}
					}else{
						for(var i=0;i<domLength;i++){
							var y=dom[i].y;
							var z=dom[i].z;
							dom[i].y=z;
							dom[i].z=_this.order-1-y;
						}
					}
				break;
				case 'y':
					if(dir){
						for(var i=0;i<domLength;i++){
							var x=dom[i].x;
							var z=dom[i].z;
							dom[i].z=_this.order-1-x;
							dom[i].x=z;
						}
					}else{
						for(var i=0;i<domLength;i++){
							var x=dom[i].x;
							var z=dom[i].z;
							dom[i].z=x;
							dom[i].x=_this.order-1-z;
						}
					}
				break;
				case 'z':
					if(dir){
						for(var i=0;i<domLength;i++){
							var y=dom[i].y;
							var x=dom[i].x;
							dom[i].y=x;
							dom[i].x=_this.order-1-y;
						}
					}else{
						for(var i=0;i<domLength;i++){
							var y=dom[i].y;
							var x=dom[i].x;
							dom[i].y=_this.order-1-x;
							dom[i].x=y;
						}
					}
				break;
			}
			_this.seletDomCorrectCoor(coor,dir);//校正转轴
			_this.runing=false;
			fnComplete&&fnComplete();
		}
	}
	for(var i=0;i<domLength;i++){
		dom[i].dom.style.transition=this.oneTime/1000+'s all ease';
		//改变ROTATE
		var drx=0,dry=0,drz=0;//默认全部旋转的0度
		var dirNumber=dir?1:-1;
		var coorsCorr={'x':dom[i].coorX,'y':dom[i].coorY,'z':dom[i].coorZ};
		for(var name in coorsCorr){
			if(coor==name){
				console.log(coorsCorr[name]);
				switch(coorsCorr[name]){
					case 'x':drx=90*dirNumber;break;
					case 'fx':drx=-90*dirNumber;break;
					case 'y':dry=90*dirNumber;break;
					case 'fy':dry=-90*dirNumber;break;
					case 'z':drz=90*dirNumber;break;
					case 'fz':drz=-90*dirNumber;break;
				}
			}
		}
		dom[i].rotateX+=drx;
		dom[i].rotateY+=dry;
		dom[i].rotateZ+=drz;
		dom[i].dom.addEventListener('transitionend',transend,false);
_this.writeCoor();		
		dom[i].dom.style.WebkitTransform='rotateZ('+dom[i].rotateZ+'deg) rotateY('+dom[i].rotateY+'deg) rotateX('+dom[i].rotateX+'deg)  translateZ('+dom[i].translateZ+'px) translate('+dom[i].translateX+'px,'+dom[i].translateY+'px)';
//		console.log(dom[i].rotateX+'deg '+dom[i].rotateY+'deg '+dom[i].rotateZ+'deg Z('+dom[i].translateZ+'px) XY('+dom[i].translateX+'px,'+dom[i].translateY+'px)');
		
	}
};

//取方向反值 for seletDomCorrectCoor方法
Cube.prototype.getUnC=function(str){
	var arr=str.split('');
	return arr.length==2?arr[1]:'f'+arr[0];
};

//在面上记录轴对应的方向 调试使用
Cube.prototype.writeCoor=function(){
	var arr=['Y上','Y下','X左','X右','Z前','Z后'];
	for(var i=0;i<this.boxsData.length;i++){
		var faces=this.boxsData[i].faces;
		for(var j=0;j<6;j++){
			faces[j].innerHTML=arr[j]+'</br>'+this.boxsData[i].coorX+' '+this.boxsData[i].coorY+' '+this.boxsData[i].coorZ+'<br/>'+this.boxsData[i].rotateX+' '+this.boxsData[i].rotateY+' '+this.boxsData[i].rotateZ;
		}
	}
}

//校正每个块的转轴  for turn方法;
Cube.prototype.seletDomCorrectCoor=function(coor,dir){
	var doms=this.seletDoms;
	var domsLength=doms.length;
	for(var i=0;i<domsLength;i++){
		var coorX=doms[i].coorX;
		var coorY=doms[i].coorY;
		var coorZ=doms[i].coorZ;
		switch(coor){
			case 'x':
				if(dir){
					doms[i].coorY=this.getUnC(coorZ);
					doms[i].coorZ=coorY;
				}else{
					doms[i].coorZ=this.getUnC(coorY);
					doms[i].coorY=coorZ;
				}
			break;
			case 'y':
				if(dir){
					doms[i].coorZ=this.getUnC(coorX);
					//doms[i].coorX=coorZ;
				}else{
					//doms[i].coorX=this.getUnC(coorZ);
					doms[i].coorZ=coorX;
				}
			break;
			case 'noz':
				if(dir){
					doms[i].coorX=this.getUnC(coorY);
					doms[i].coorY=coorX;
				}else{
					doms[i].coorY=this.getUnC(coorX);
					doms[i].coorX=coorY;
				}
			break;
		}
	}
};

//设置魔法拧动一次的时长 毫秒
Cube.prototype.setOneTime=function(n){
	this.oneTime=n;
};




var cube=new Cube('mf',{vColor:'#999',order:3,mouseSen:0.5,borderLength:200});
var aInt=document.getElementsByTagName('input');
aInt[3].onclick=function(){
	cube.turn(aInt[0].value,aInt[1].value,aInt[2].value);
}
</script>
